{
  "name": "asynquence",
  "version": "0.3.3-b",
  "description": "asynquence: async sequences & gates for flow-control",
  "main": "./asq.js",
  "scripts": {
    "test": "./node-tests.js",
    "build-core": "./build-core.js"
  },
  "devDependencies": {
    "uglify-js": "~2.4.8",
    "q": "~0.9.7"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/getify/asynquence.git"
  },
  "keywords": [
    "async",
    "flow-control",
    "sequences",
    "promise",
    "iterator",
    "generator"
  ],
  "bugs": {
    "url": "https://github.com/getify/asynquence/issues",
    "email": "getify@gmail.com"
  },
  "homepage": "http://github.com/getify/asynquence",
  "author": {
    "name": "Kyle Simpson",
    "email": "getify@gmail.com"
  },
  "license": "MIT",
  "readme": "# asynquence\n\nA lightweight (**~1.8k** minzipped) micro-lib for asynchronous flow-control using sequences and gates.\n\n## Explanation\n\n### TL;DR: By Example\n\n* [Sequences & gates](https://gist.github.com/getify/5959149), at a glance\n* Refactoring [\"callback hell\"-style to asynquence](https://gist.github.com/getify/8459026)\n* Example/explanation of [promise-style sequences](https://gist.github.com/jakearchibald/0e652d95c07442f205ce#comment-977119)\n* More advanced example of [\"nested\" composition of sequences](https://gist.github.com/getify/10273f3de07dda27ebce)\n* [Iterable sequences](#iterable-sequences): [sync loop](https://gist.github.com/getify/8211148#file-ex1-sync-iteration-js) and [async loop](https://gist.github.com/getify/8211148#file-ex2-async-iteration-js) and [async batch iteration of list](https://gist.github.com/getify/8464917)\n* API [Usage Examples](#usage-examples)\n\n### Sequences\nSay you want to perform two or more asynchronous tasks one after the other (like animation delays, XHR calls, file I/O, etc). You need to set up an ordered series of tasks and make sure the previous one finishes before the next one is processed. You need a **sequence**.\n\nYou create a sequence by calling `ASQ(...)`. **Each time you call `ASQ()`, you create a new, separate sequence.**\n\nTo create a new step, simply call `then(...)` with a function. That function will be executed when that step is ready to be processed, and it will be passed as its first parameter the completion trigger. Subsequent parameters, if any, will be any messages passsed on from the immediately previous step.\n\nThe completion trigger that your step function(s) receive can be called directly to indicate success, or you can add the `fail` flag (see examples below) to indicate failure of that step. In either case, you can pass one or more messages onto the next step (or the next failure handler) by simply adding them as parameters to the call.\n\nIf you register a step using `then(...)` on a sequence which is already currently complete, that step will be processed at the next opportunity. Otherwise, calls to `then(...)` will be queued up until that step is ready for processing.\n\nYou can register multiple steps, and multiple failure handlers. However, messages from a previous step (success or failure completion) will only be passed to the immediately next registered step (or the next failure handler). If you want to propagate along a message through multiple steps, you must do so yourself by making sure you re-pass the received message at each step completion.\n\nTo listen for any step failing, call `or(...)` on your sequence to register a failure callback. You can call `or()` as many times as you would like. If you call `or()` on a sequence that has already been flagged as failed, the callback you specify will just be executed at the next opportunity.\n\n### Gates\nIf you have two or more tasks to perform at the same time, but want to wait for them all to complete before moving on, you need a **gate**.\n\nCalling `gate(..)` with two or more functions creates a step that is a parallel gate across those functions, such that the single step in question isn't complete until all segments of the parallel gate are **successfully** complete.\n\nFor parallel gate steps, each segment of that gate will receive a copy of the message(s) passed from the previous step. Also, all messages from the segments of this gate will be passed along to the next step (or the next failure handler, in the case of a gate segment indicating a failure).\n\n### Conveniences\nThere are a few convenience methods on the API, as well:\n\n* `pipe(..)` takes one or more completion triggers from other sequences, treating each one as a separate step in the sequence in question. These completion triggers will, in turn, be piped both the success and failure streams from the sequence.\n\n    `Sq.pipe(done)` is sugar short-hand for `Sq.then(done).or(done.fail)`.\n\n* `seq(..)` takes one or more functions, treating each one as a separate step in the sequence in question. These functions are expected to return new sequences, from which, in turn, both the success and failure streams will be piped back to the sequence in question.\n\n    `seq(Fn)` is sugar short-hand for `then(function(done){ Fn.apply(null,[].slice.call(arguments,1)).pipe(done); })`.\n\n    This method will also accept *asynquence* sequence instances directly. `seq(Sq)` is sugar short-hand for `then(function(done){ Sq.pipe(done); })`.\n\n    Additionally, this method can accept, either directly or through function-call, an [Iterable Sequence](#iterable-sequences). `seq(iSq)` is (sort-of) sugar short-hand for `then(function(done){ iSq.then(done).or(done.fail); })`.\n\n* `val(..)` takes one or more functions, treating each one as a separate step in the sequence in question. These functions can each optionally return a value, each value of which will, in turn, be passed as the completion value for that sequence step.\n\n    `val(Fn)` is sugar short-hand for `then(function(done){ done(Fn.apply(null,[].slice.call(arguments,1))); })`.\n\n    This method will also accept non-function values as sequence value-messages. `val(Va)` is sugar short-hand for `then(function(done){ done(Va); })`.\n\n* `promise(..)` takes one or more [standard Promises/A+ compliant](http://promisesaplus.com/) promises, and subsumes them into the sequence. See [Promises/A+ Compliance](#promisesa-compliance) below for more information.\n\n    `promise(Pr)` is sugar short-hand for `then(function(done){ Pr.then(done,done.fail); })`.\n\n    This method will also accept function(s) which return promises. `promise(Fn)` is sugar short-hand for `then(function(done){ Fn.apply(null,[].slice.call(arguments,1)).then(done,done.fail); })`.\n\n* `fork()` creates a new sequence that forks off of the main sequence. Success or Error message(s) stream along to the forked sequence as expected, but the main sequence continues as its own sequence beyond the fork point, and neither sequence will have any further effect on the other.\n\n    This API method is primarily useful to create multiple \"listeners\" at the same point of a sequence. For example: `sq = ASQ()...; sq2 = sq.fork().then(..); sq3 = sq.fork().then(..); sq.then(..)`. In that snippet, there'd be 3 `then(..)` listeners that would be equally and simultaneously triggered when the main `sq` sequence reached that point.\n\n    **Note:** Unlike most other API methods, `fork()` returns a new sequence instance, so chaining after `fork()` would not be chaining off of the main sequence but off of the forked sequence.\n\n    `sq.fork()` is (sort-of) sugar short-hand for `ASQ().seq(sq)`.\n\n* `errfcb` is a flag on the triggers that are passed into `then(..)` steps and `gate(..)` segments. If you're using methods which expect an \"error-first\" style (aka, \"node-style\") callback, `{trigger}.errfcb` provides a properly formatted callback for the occasion.\n\n    If the \"error-first\" callback is then invoked with the first (\"error\") parameter set, the main sequence is flagged for error as usual. Otherwise, the main sequence proceeds as success. Messages sent to the callback are passed through to the main sequence as success/error as expected.\n\n    `ASQ(function(done){ somethingAsync(done.errfcb); })` is sugar short-hand for `ASQ(function(done){ somethingAsync(function(err){ if (err) done.fail(err); else done.apply(null,[].slice.call(arguments,1))}); })`.\n\nYou can also `abort()` a sequence at any time, which will prevent any further actions from occurring on that sequence (all callbacks will be ignored). The call to `abort()` can happen on the sequence API itself, or using the `abort` flag on a completion trigger in any step (see example below).\n\n`ASQ.messages(..)` wraps a set of values as a ASQ-branded array, making it easier to pass multiple messages at once, and also to make it easier to distinguish a normal array (a value) from a value-messages container array, using `ASQ.isMessageWrapper(..)`.\n\nIf you want to test if any arbitrary object is an *asynquence* sequence instance, use `ASQ.isSequence(..)`.\n\n`ASQ.iterable(..)` is added by the `iterable-sequence` contrib plugin. See [Iterable Sequences](#iterable-sequences) below for more information.\n\n`ASQ.noConflict()` rolls back the global `ASQ` identifier and returns the current API instance to you. This can be used to keep your global namespace clean, or it can be used to have multiple simultaneous libraries (including separate versions/copies of *asynquence*!) in the same program without conflicts over the `ASQ` global identifier.\n\n### Plugin Extensions\n`ASQ.extend( {name}, {build} )` allows you to specify an API extension, giving it a `name` and a `build` function callback that should return the implementation of your API extension. The `build` callback is provided two parameters, the sequence `api` instance, and an `internals(..)` method, which lets you get or set values of various internal properties (generally, don't use this if you can avoid it).\n\nExample:\n\n```js\n// \"foobar\" plugin, which injects message \"foobar!\"\n// into the sequence stream\nASQ.extend(\"foobar\",function __build__(api,internals){\n    return function __foobar__() {\n        api.val(function __val__(){\n            return \"foobar!\";\n        });\n\n        return api;\n    };\n});\n\nASQ()\n.foobar() // our custom plugin!\n.val(function(msg){\n    console.log(msg); // foobar!\n});\n```\n\nSee the `/contrib/*` plugins for more complex examples of how to extend the *asynquence* API.\n\nThe `/contrib/*` plugins provide a variety of [optional contrib plugins](https://github.com/getify/asynquence/blob/master/contrib/README.md) as helpers for async flow-controls.\n\nFor browser usage, simply include the `asq.js` library file and then the `contrib.js` file. For node.js, these contrib plugins are available as a separate npm module `asynquence-contrib`.\n\n#### Iterable Sequences\nOne of the contrib plugins provided is `iterable-sequence`. Unlike other plugins, which add methods onto the sequence instance API, this plugin adds a new method directly onto the main module API: `ASQ.iterable(..)`. Calling `ASQ.iterable(..)` creates a special iterable sequence, as compared to calling `ASQ(..)` to create a normal *asynquence* sequence.\n\nAn iterable sequence works similarly to normal *asynquence* sequences, but a bit different. `then(..)` still registers steps on the sequence, but it's basically just an alias of `val(..)`, because the most important difference is that steps of an iterable sequence **are not passed completion triggers**.\n\nInstead, an iterable sequence instance API has a `next(..)` method on it, which will allow the sequence to be externally iterated, one step at a time. Whatever is passed to `next(..)` is sent as step messages to the current step in the sequence. `next(..)` always returns an object like:\n\n```js\n{\n    value: ...          // return messages\n    done: true|false    // sequence iteration complete?\n}\n```\n\n`value` is any return message(s) from the `next(..)` invocation (`undefined` otherwise). `done` is `true` if the previously iterated step was (so far) the last registered step in the iterable sequence, or `false` if there's still more sequence steps queued up.\n\nJust like with normal *asynquence* sequences, register one or more error listeners on the iterable sequence by calling `or(..)`. If a step results in some error (either accidentally or manually via `throw ..`), the iterable sequence is flagged in the error state, and any error messages are passed to the registered `or(..)` listeners.\n\nAlso, just like `next(..)` externally controls the normal iteration flow of the sequence, `throw(..)` externally \"throws\" an error into the iterable sequence, triggering the `or(..)` flow as above. Iterable sequences can be `abort()`d just as normal *asynquence* sequences.\n\nIterable sequences are a special subset of sequences, and as such, some of the normal *asynquence* API variations do not exist, such as `gate(..)`, `seq(..)`, and `promise(..)`.\n\n```js\nfunction step(num) {\n    return \"Step \" + num;\n}\n\nvar sq = ASQ.iterable()\n    .then(step)\n    .then(step)\n    .then(step);\n\nfor (var i=0, ret;\n    !(ret && ret.done) && (ret = sq.next(i+1));\n    i++\n) {\n    console.log(ret.value);\n}\n// Step 1\n// Step 2\n// Step 3\n```\n\nThis example shows sync iteration with a `for` loop, but of course, `next(..)` can be called in various [async fashions to iterate](https://gist.github.com/getify/8211148#file-ex2-async-iteration-js) the sequence over time.\n\n### Multiple parameters\nAPI methods take one or more functions as their parameters. `gate(..)` treats multiple functions as segments in the same gate. The other API methods (`then(..)`, `or(..)`, `pipe(..)`, `seq(..)`, and `val(..)`) treat multiple parameters as just separate subsequent steps in the respective sequence. These methods don't accept arrays of functions (that you might build up programatically), but since they take multiple parameters, you can use `.apply(..)` to spread those out.\n\n### Promises/A+ Compliance\n**The goal of *asynquence* is that you should be able to use it as your primary async flow-control library, without the need for other Promises implementations.**\n\nThis lib is intentionally designed to hide/abstract the idea of Promises, such that you can do quick and easy async flow-control programming without creating Promises directly.\n\nAs such, the *asynquence* API itself is *not [Promises/A+](http://promisesaplus.com/) compliant*, nor *should* it be, because the \"promises\" used are hidden underneath *asynquence*'s API. **Note:** the implementation promises behave predictably like standard Promises.\n\nIf you are also using other Promises implementations alongside *asynquence*, you *can* quite easily receive and consume a regular Promise value from some other method into the signal/control flow for an *asynquence* sequence.\n\nFor example, if using both the [Q promises library](https://github.com/kriskowal/q) and *asynquence*:\n\n```js\n// Using *Q*, make a standard Promise out\n// of jQuery's Ajax \"promise\"\nvar p = Q( $.ajax(..) );\n\n// Now, asynquence flow-control including a\n// standard Promise\nASQ()\n.then(function(done){\n    setTimeout(done,100);\n})\n// subsume a standard Promise into the sequence\n.promise(p)\n.val(function(ajaxResp){\n    console.log(ajaxResp);\n});\n```\n\n**Despite API similarities** (like the presence of `then(..)` on the API), an *asynquence* instance is **not** designed to be used *as a Promise value* linked/passed to another standard Promise.\n\nTrying to do so will likely cause unexpected behavior, because Promises/A+ insists on problematic (read: \"dangerous\") duck-typing for objects that have a `then()` method, as *asynquence* instances do.\n\n## Browser, node.js (CommonJS), AMD: ready!\n\nThe *asynquence* library is packaged with a light variation of the [UMD (universal module definition)](https://github.com/umdjs/umd) pattern, which means the same file is suitable for inclusion either as a normal browser .js file, as a node.js module, or as an AMD module. Can't get any simpler than that, can it?\n\nFor browser usage, simply include the `asq.js` library file. For node.js usage, install the `asynquence` package via npm, then `require(..)` the module:\n\n```js\nvar ASQ = require(\"asynquence\");\n```\n\n**Note:** The `ASQ.noConflict()` method really only makes sense when used in a normal browser global namespace environment. It **should not** be used when the node.js or AMD style modules are your method of inclusion.\n\n## Usage Examples\n\nUsing the following example setup:\n\n```js\nfunction fn1(done) {\n    alert(\"Step 1\");\n    setTimeout(done,1000);\n}\n\nfunction fn2(done) {\n    alert(\"Step 2\");\n    setTimeout(done,1000);\n}\n\nfunction yay() {\n    alert(\"Done!\");\n}\n```\n\nExecute `fn1`, then `fn2`, then finally `yay`:\n\n```js\nASQ(fn1)\n.then(fn2)\n.then(yay);\n```\n\nPass messages from step to step:\n\n```js\nASQ(function(done){\n    setTimeout(function(){\n        done(\"hello\");\n    },1000);\n})\n.then(function(done,msg1){\n    setTimeout(function(){\n        done(msg1,\"world\");\n    },1000);\n})\n.then(function(_,msg1,msg2){ // basically ignoring this step's completion trigger (`_`)\n    alert(\"Greeting: \" + msg1 + \" \" + msg2);\n    // 'Greeting: hello world'\n});\n```\n\nHandle step failure:\n\n```js\nASQ(function(done){\n    setTimeout(function(){\n        done(\"hello\");\n    },1000);\n})\n.then(function(done,msg1){\n    setTimeout(function(){\n        // note the `fail` flag here!!\n        done.fail(msg1,\"world\");\n    },1000);\n})\n.then(function(){\n    // sequence fails, won't ever get called\n})\n.or(function(msg1,msg2){\n    alert(\"Failure: \" + msg1 + \" \" + msg2);\n    // 'Failure: hello world'\n});\n```\n\nCreate a step that's a parallel gate:\n\n```js\nASQ()\n// normal async step\n.then(function(done){\n    setTimeout(function(){\n        done(\"hello\");\n    },1000);\n})\n// parallel gate step (segments run in parallel)\n.gate(\n    function(done,greeting){ // gate segment\n        setTimeout(function(){\n            // 2 gate messages!\n            done(greeting,\"world\");\n        },500);\n    },\n    function(done,greeting){ // gate segment\n        setTimeout(function(){\n            // only 1 gate message!\n            done(greeting + \" mikey\");\n        },100);\n        // this segment finishes first, but message\n        // still kept \"in order\"\n    }\n)\n.then(function(_,msg1,msg2){\n    // msg1 is an array of the 2 gate messages\n    // from the first segment\n    // msg2 is the single message (not an array)\n    // from the second segment\n\n    alert(\"Greeting: \" + msg1[0] + \" \" + msg1[1]);\n    // 'Greeting: hello world'\n    alert(\"Greeting: \" + msg2);\n    // 'Greeting: hello mikey'\n});\n```\n\nUse `pipe(..)`, `seq(..)`, and `val(..)` helpers:\n\n```js\nvar seq = ASQ()\n.then(function(done){\n    ASQ()\n    .then(function(done){\n        setTimeout(function(){\n            done(\"Hello World\");\n        },100);\n    })\n    .pipe(done); // pipe sequence output to `done` completion trigger\n})\n.val(function(msg){ // NOTE: no completion trigger passed in!\n    return msg.toUpperCase(); // map return value as step output\n})\n.seq(function(msg){ // NOTE: no completion trigger passed in!\n    var seq = ASQ();\n\n    seq\n    .then(function(done){\n        setTimeout(function(){\n            done(msg.split(\" \")[0]);\n        },100);\n    });\n\n    return seq; // pipe this sub-sequence back into the main sequence\n})\n.then(function(_,msg){\n    alert(msg); // \"HELLO\"\n});\n```\n\nAbort a sequence in progress:\n\n```js\nvar seq = ASQ()\n.then(fn1)\n.then(fn2)\n.then(yay);\n\nsetTimeout(function(){\n    // will stop the sequence before running\n    // steps `fn2` and `yay`\n    seq.abort();\n},100);\n\n// same as above\nASQ()\n.then(fn1)\n.then(function(done){\n    setTimeout(function(){\n        // `abort` flag will stop the sequence\n        // before running steps `fn2` and `yay`\n        done.abort();\n    },100);\n})\n.then(fn2)\n.then(yay);\n```\n\n## Builds\n\nThe core library file can be built (minified) with an included utility:\n\n```\n./build-core.js\n```\n\nHowever, the recommended way to invoke this utility is via npm:\n\n```\nnpm run-script build-core\n```\n\n## License\n\nThe code and all the documentation are released under the MIT license.\n\nhttp://getify.mit-license.org/\n",
  "readmeFilename": "README.md",
  "_id": "asynquence@0.3.3-b",
  "_from": "asynquence@0.3.3-b"
}
